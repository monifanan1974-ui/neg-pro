cat > backend/engine_entrypoint.py <<'PY'
# backend/engine_entrypoint.py
# QuestionnaireEngine: small rules matcher + HTML report.

from __future__ import annotations
import json, os
from pathlib import Path
from typing import Any, Dict, List, Tuple

from .signal_adapter import SignalAdapter

ROOT = Path(__file__).resolve().parents[1]
RULES_PATHS = [
    ROOT / "data" / "rules-engine.json",
    ROOT / "rules-engine.json",
]
MAP_PATH = ROOT / "data" / "rules_signal_map.json"

def _read_json(p: Path) -> Any:
    with open(p, "r", encoding="utf-8") as f:
        return json.load(f)

def _load_rules() -> Dict[str, Any]:
    for p in RULES_PATHS:
        if p.exists():
            return _read_json(p)
    raise FileNotFoundError("rules-engine.json not found in data/ or project root.")

def _safe_get(d: dict, path: List[str], default=None):
    cur = d
    for k in path:
        if isinstance(cur, dict) and k in cur:
            cur = cur[k]
        else:
            return default
    return cur

def _intersects(a: List[str], b: List[str]) -> bool:
    return bool(set(a) & set(b))

class QuestionnaireEngine:
    def __init__(self, debug: bool = False):
        self.debug = bool(debug)
        self.rules = _load_rules()
        self.mapping = _read_json(MAP_PATH) if MAP_PATH.exists() else {}
        self.adapter = SignalAdapter(self.mapping)

    def _match_rules(self, ctx: Dict[str, Any]) -> List[Dict[str, Any]]:
        """Return rules whose conditions match our context."""
        rules = self.rules.get("rules") or []
        hits: List[Dict[str, Any]] = []
        for r in rules:
            cond = r.get("conditions") or {}
            ok = True

            # persona.types
            persona_types = _safe_get(cond, ["persona", "types"], [])
            if persona_types:
                if not _intersects(persona_types, _safe_get(ctx, ["persona", "types"], [])):
                    ok = False

            # emotions
            if ok and cond.get("emotions"):
                if not _intersects(cond["emotions"], ctx.get("emotions", [])):
                    ok = False

            # tags
            if ok and cond.get("tags"):
                if not _intersects(cond["tags"], ctx.get("tags", [])):
                    ok = False

            if ok:
                hits.append(r)
        return hits

    def _render_html(self, answers: Dict[str, Any], ctx: Dict[str, Any], recs: List[Dict[str, Any]]) -> str:
        # Highlights from recommendations.text
        hi_items: List[str] = []
        for r in recs:
            for it in (r.get("recommendations") or [])[:3]:
                t = str(it.get("text", "")).strip()
                if t:
                    hi_items.append(f"<li>{t}</li>")
            if len(hi_items) >= 6:
                break

        hi_html = "<ul>" + "".join(hi_items) + "</ul>" if hi_items else "<p>—</p>"

        badges = " ".join(
            [f'<span class="badge">{x}</span>' for x in (
                (ctx.get("persona", {}).get("types") or []) +
                (ctx.get("emotions") or []) +
                (ctx.get("tags") or [])
            )]
        )

        summary = "Report generated from rules-engine matches. If highlights are few, expand answers or adjust mapping."

        # Minimal CSS to look decent in iframe
        return f"""
<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <title>Strategic Negotiation Report</title>
    <style>
      body {{ font-family: Inter, system-ui, Arial; color: #e7e7ea; background: #11131a; }}
      .card {{ background:#171923; border:1px solid #2b2f3a; border-radius:14px; padding:20px; }}
      .title {{ font-size: 24px; font-weight: 800; margin:0 0 8px; }}
      .meta  {{ color:#9aa3b2; font-size: 13px; }}
      .grid {{ display:grid; grid-template-columns: 1fr 1fr; gap:20px; }}
      .badge {{ display:inline-block; padding:4px 8px; border-radius:999px; background:#232637; color:#b8c1d9; font-size:12px; margin-right:6px; }}
      ul {{ margin: 0.5rem 0 0 1.2rem; }}
      h3 {{ margin:0 0 6px; }}
      .muted {{ color:#9aa3b2 }}
    </style>
  </head>
  <body>
    <div class="card">
      <div class="title">Strategic Negotiation Report</div>
      <div class="meta">{answers.get("culture_region","-")} • Persona: {", ".join(ctx.get("persona",{{}}).get("types",[])) or "-"} • Emotions: {", ".join(ctx.get("emotions",[])) or "-"}</div>

      <div class="grid" style="margin-top:14px;">
        <div>
          <h3>Highlights</h3>
          {hi_html}
        </div>
        <div>
          <h3>Tags</h3>
          <div>{badges or "<span class='muted'>—</span>"}</div>
        </div>
      </div>

      <div style="margin-top:14px;">
        <h3>Summary</h3>
        <p class="muted">{summary}</p>
      </div>

      <details style="margin-top:10px;">
        <summary class="muted">Debug Snapshot</summary>
        <pre class="muted" style="white-space:pre-wrap; font-size:12px;">{json.dumps({"context": ctx, "matched_rules": [r.get("id") for r in recs]}, ensure_ascii=False, indent=2)}</pre>
      </details>
    </div>
  </body>
</html>
""".strip()

    def run(self, answers: Dict[str, Any]) -> Dict[str, Any]:
        # normalize shape
        if "answers" in answers and isinstance(answers["answers"], dict):
            a = answers["answers"]
        else:
            a = answers

        ctx = self.adapter.build_context(a)
        hits = self._match_rules(ctx)
        html = self._render_html(a, ctx, hits)

        return {
            "status": "ok",
            "html": html,
            "chart_data": None,
            "debug": self.debug and {"ctx": ctx, "hits": [h.get("id") for h in hits]}
        }

# === Diagnostics: /about ======================================================
from datetime import datetime
from flask import jsonify

@app.get("/about")
def about():
    return jsonify({
        "ok": True,
        "engine_mode": "full",
        "build": "negpro-diag-stage1",
        "ts": datetime.utcnow().isoformat() + "Z"
    })
# ============================================================================
